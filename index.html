<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Weekly Games | WebGL & Canvas Arcade</title>
  <style>
    :root {
      --bg: #0c0f17;
      --card: rgba(255, 255, 255, 0.04);
      --panel: rgba(255, 255, 255, 0.08);
      --accent: #8ce0ff;
      --accent-2: #7cf29c;
      --text: #eef2ff;
      --muted: #a5b4cc;
      --border: rgba(255, 255, 255, 0.08);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      color: var(--text);
      background: radial-gradient(circle at 15% 20%, rgba(124, 242, 156, 0.15), transparent 25%),
                  radial-gradient(circle at 80% 0%, rgba(140, 224, 255, 0.2), transparent 30%),
                  var(--bg);
      min-height: 100vh;
      line-height: 1.6;
    }
    header {
      padding: 32px 24px 12px;
      max-width: 1100px;
      margin: 0 auto;
    }
    .hero {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 32px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      backdrop-filter: blur(12px);
    }
    h1 {
      margin: 0 0 8px;
      font-size: 32px;
      letter-spacing: -0.01em;
    }
    p {
      margin: 0 0 12px;
      color: var(--muted);
    }
    .hero-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 16px;
    }
    .button {
      padding: 12px 16px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      text-decoration: none;
      font-weight: 600;
      transition: transform 160ms ease, box-shadow 160ms ease, background 160ms ease;
      cursor: pointer;
    }
    .button.primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #0d0f15;
      border: none;
      box-shadow: 0 12px 30px rgba(124, 242, 156, 0.35);
    }
    .button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
    }
    main {
      max-width: 1100px;
      margin: 0 auto;
      padding: 12px 24px 64px;
    }
    .section-title {
      margin: 28px 0 12px;
      font-size: 22px;
    }
    .games-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px;
    }
    .game-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 16px 40px rgba(0,0,0,0.32);
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.05);
      color: var(--muted);
      font-size: 13px;
      width: fit-content;
    }
    .canvas-frame {
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #080a10;
      position: relative;
      min-height: 240px;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .status {
      color: var(--muted);
      font-size: 14px;
    }
    .list {
      padding-left: 18px;
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 14px;
    }
    footer {
      text-align: center;
      color: var(--muted);
      padding: 12px 0 32px;
      font-size: 14px;
    }
    @media (max-width: 600px) {
      h1 { font-size: 26px; }
      .hero { padding: 24px; }
      .canvas-frame { min-height: 210px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="hero">
      <div class="tag">Weekly Games · WebGL + Canvas</div>
      <h1>Arcade built with modern web graphics</h1>
      <p>Host multiple experiments that mix 3D (WebGL) and 2D (HTML Canvas) playables.
        Open-source and designed for GitHub Pages.</p>
      <div class="hero-actions">
        <a class="button primary" href="#games">Jump to games</a>
        <a class="button" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API" target="_blank" rel="noreferrer noopener">WebGL docs</a>
        <a class="button" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" target="_blank" rel="noreferrer noopener">Canvas API</a>
      </div>
    </div>
  </header>

  <main id="games">
    <h2 class="section-title">Playables</h2>
    <div class="games-grid">
      <article class="game-card" aria-labelledby="orbit-title">
        <div class="tag">3D · WebGL</div>
        <h3 id="orbit-title">Orbital Drift</h3>
        <p>Orbit a satellite around a glowing world and paint the sky with trails.</p>
        <div id="orbit-canvas" class="canvas-frame"></div>
        <div class="controls">
          <button class="button primary" id="orbit-toggle">Start</button>
          <button class="button" id="orbit-reset">Restart</button>
        </div>
        <div class="status" id="orbit-status">Status: stopped</div>
        <ul class="list">
          <li>Drag to rotate the camera.</li>
          <li>Pure WebGL, no external libraries.</li>
        </ul>
      </article>

      <article class="game-card" aria-labelledby="dodger-title">
        <div class="tag">2D · Canvas · Keyboard</div>
        <h3 id="dodger-title">Starfield Dodger</h3>
        <p>Dodge falling meteors, collect energy cells, and keep the streak alive.</p>
        <div class="canvas-frame">
          <canvas id="dodger-canvas" width="480" height="260" aria-label="Starfield dodger game"></canvas>
        </div>
        <div class="controls">
          <button class="button primary" id="dodger-toggle">Start</button>
          <button class="button" id="dodger-reset">Reset</button>
        </div>
        <div class="status" id="dodger-status">Status: stopped · Controls: ← → or A D</div>
        <ul class="list">
          <li>Keyboard move left/right.</li>
          <li>Canvas 2D rendering.</li>
        </ul>
      </article>
    </div>
  </main>

  <footer>
    Built for GitHub Pages. Add more games in new cards or link to subdirectories.
  </footer>

  <script>
    // WebGL orbital toy
    (function initOrbitGame() {
      const container = document.getElementById('orbit-canvas');
      const toggleBtn = document.getElementById('orbit-toggle');
      const resetBtn = document.getElementById('orbit-reset');
      const status = document.getElementById('orbit-status');

      const canvas = document.createElement('canvas');
      container.appendChild(canvas);
      const gl = canvas.getContext('webgl', { antialias: true });
      if (!gl) {
        status.textContent = 'WebGL not supported in this browser.';
        toggleBtn.disabled = true;
        resetBtn.disabled = true;
        return;
      }

      const vertSrc = `
        attribute vec3 position;
        attribute vec3 color;
        uniform mat4 uMVP;
        varying vec3 vColor;
        void main() {
          vColor = color;
          gl_Position = uMVP * vec4(position, 1.0);
        }
      `;
      const fragSrc = `
        precision mediump float;
        varying vec3 vColor;
        void main() {
          gl_FragColor = vec4(vColor, 1.0);
        }
      `;

      function compile(type, src) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          throw new Error(gl.getShaderInfoLog(shader));
        }
        return shader;
      }

      const program = gl.createProgram();
      gl.attachShader(program, compile(gl.VERTEX_SHADER, vertSrc));
      gl.attachShader(program, compile(gl.FRAGMENT_SHADER, fragSrc));
      gl.linkProgram(program);
      gl.useProgram(program);

      // Vertex positions grouped per face (front, back, top, bottom, right, left)
      const positions = new Float32Array([
        // Front
        -1, -1,  1,  1, -1,  1,  1,  1,  1,  -1,  1,  1,
        // Back
        -1, -1, -1, -1,  1, -1,  1,  1, -1,   1, -1, -1,
        // Top
        -1,  1, -1, -1,  1,  1,  1,  1,  1,   1,  1, -1,
        // Bottom
        -1, -1, -1,  1, -1, -1, 1, -1,  1,  -1, -1,  1,
        // Right
         1, -1, -1, 1,  1, -1, 1, 1, 1,   1, -1, 1,
        // Left
        -1, -1, -1, -1, -1, 1, -1, 1, 1,  -1, 1, -1,
      ]);

      const colors = new Float32Array([
        // Front (cyan)
        0.35, 0.8, 1, 0.35, 0.8, 1, 0.35, 0.8, 1, 0.35, 0.8, 1,
        // Back (blue)
        0.2, 0.5, 0.9, 0.2, 0.5, 0.9, 0.2, 0.5, 0.9, 0.2, 0.5, 0.9,
        // Top (mint)
        0.6, 1, 0.8, 0.6, 1, 0.8, 0.6, 1, 0.8, 0.6, 1, 0.8,
        // Bottom (amber)
        1, 0.8, 0.45, 1, 0.8, 0.45, 1, 0.8, 0.45, 1, 0.8, 0.45,
        // Right (purple)
        0.65, 0.45, 1, 0.65, 0.45, 1, 0.65, 0.45, 1, 0.65, 0.45, 1,
        // Left (pink)
        1, 0.5, 0.7, 1, 0.5, 0.7, 1, 0.5, 0.7, 1, 0.5, 0.7,
      ]);

      const indices = new Uint16Array([
        0, 1, 2, 0, 2, 3,       // front
        4, 5, 6, 4, 6, 7,       // back
        8, 9,10, 8,10,11,       // top
       12,13,14,12,14,15,       // bottom
       16,17,18,16,18,19,       // right
       20,21,22,20,22,23        // left
      ]);

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

      const colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      const positionLoc = gl.getAttribLocation(program, 'position');
      const colorLoc = gl.getAttribLocation(program, 'color');
      const mvpLoc = gl.getUniformLocation(program, 'uMVP');

      function enableBuffer(buffer, location, size) {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(location, size, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(location);
      }

      const mat4 = {
        create() { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); },
        perspective(out, fovy, aspect, near, far) {
          const f = 1.0 / Math.tan(fovy / 2);
          out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
          out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
          out[8] = 0; out[9] = 0; out[10] = (far + near) / (near - far); out[11] = -1;
          out[12] = 0; out[13] = 0; out[14] = (2 * far * near) / (near - far); out[15] = 0;
          return out;
        },
        multiply(out, a, b) {
          const o = new Float32Array(16);
          for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
              o[r * 4 + c] =
                a[r * 4 + 0] * b[0 * 4 + c] +
                a[r * 4 + 1] * b[1 * 4 + c] +
                a[r * 4 + 2] * b[2 * 4 + c] +
                a[r * 4 + 3] * b[3 * 4 + c];
            }
          }
          out.set(o);
          return out;
        },
        translate(out, x, y, z) {
          out[12] += x;
          out[13] += y;
          out[14] += z;
          return out;
        },
        rotateY(out, rad) {
          const c = Math.cos(rad);
          const s = Math.sin(rad);
          const m10 = out[0], m11 = out[1], m12 = out[2], m13 = out[3];
          const m20 = out[8], m21 = out[9], m22 = out[10], m23 = out[11];
          out[0] = m10 * c + m20 * s;
          out[1] = m11 * c + m21 * s;
          out[2] = m12 * c + m22 * s;
          out[3] = m13 * c + m23 * s;
          out[8] = m20 * c - m10 * s;
          out[9] = m21 * c - m11 * s;
          out[10] = m22 * c - m12 * s;
          out[11] = m23 * c - m13 * s;
          return out;
        }
      };

      let running = false;
      let animationId;
      let start = performance.now();
      const projection = mat4.create();
      const view = mat4.create();

      function resize() {
        const w = container.clientWidth || 480;
        const h = container.clientHeight || 320;
        canvas.width = w;
        canvas.height = h;
        gl.viewport(0, 0, w, h);
        mat4.perspective(projection, Math.PI / 4, w / h, 0.1, 100);
        view.set([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,-8,1]);
      }
      resize();
      window.addEventListener('resize', resize);

      function drawCube(model, scale = 1) {
        const scaled = model.slice();
        scaled[0] *= scale; scaled[5] *= scale; scaled[10] *= scale;
        const mv = mat4.multiply(mat4.create(), view, scaled);
        const mvp = mat4.multiply(mat4.create(), projection, mv);
        gl.uniformMatrix4fv(mvpLoc, false, mvp);
        enableBuffer(positionBuffer, positionLoc, 3);
        enableBuffer(colorBuffer, colorLoc, 3);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
      }

      function animate(now) {
        if (!running) return;
        const t = (now - start) / 1000;
        gl.clearColor(0.03, 0.05, 0.08, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);

        const core = mat4.create();
        mat4.rotateY(core, t * 0.6);
        drawCube(core, 1.2);

        const orbiter = mat4.create();
        mat4.rotateY(orbiter, t * 1.5);
        mat4.translate(orbiter, 2.6, Math.sin(t) * 0.5, 0);
        mat4.rotateY(orbiter, t * 2.2);
        drawCube(orbiter, 0.5);

        animationId = requestAnimationFrame(animate);
      }

      function setRunning(next) {
        running = next;
        status.textContent = running ? 'Status: running' : 'Status: stopped';
        toggleBtn.textContent = running ? 'Pause' : 'Start';
        if (running) {
          start = performance.now();
          animationId = requestAnimationFrame(animate);
        } else if (animationId) {
          cancelAnimationFrame(animationId);
        }
      }

      toggleBtn.addEventListener('click', () => setRunning(!running));
      resetBtn.addEventListener('click', () => {
        start = performance.now();
        setRunning(true);
      });
      setRunning(true);
    })();

    // Canvas dodger game
    (function initDodger() {
      const canvas = document.getElementById('dodger-canvas');
      const ctx = canvas.getContext('2d');
      const toggleBtn = document.getElementById('dodger-toggle');
      const resetBtn = document.getElementById('dodger-reset');
      const status = document.getElementById('dodger-status');

      const SPAWN_INTERVAL_MS = 700;
      const SCORE_INTERVAL_MS = 16; // ~62fps cadence for incremental scoring
      const player = { x: canvas.width / 2 - 16, y: canvas.height - 40, w: 32, h: 16, speed: 4.5, vx: 0 };
      let obstacles = [];
      let energy = [];
      let lastSpawn = 0;
      let score = 0;
      let running = false;
      let frameId;
      let scoreAccumulator = 0;

      const keys = new Set();
      document.addEventListener('keydown', (e) => {
        if (['ArrowLeft', 'a', 'A'].includes(e.key)) keys.add('left');
        if (['ArrowRight', 'd', 'D'].includes(e.key)) keys.add('right');
      });
      document.addEventListener('keyup', (e) => {
        if (['ArrowLeft', 'a', 'A'].includes(e.key)) keys.delete('left');
        if (['ArrowRight', 'd', 'D'].includes(e.key)) keys.delete('right');
      });

      function spawnObject(list, type) {
        const size = type === 'energy' ? 10 : 18;
        list.push({
          x: Math.random() * (canvas.width - size),
          y: -size,
          size,
          speed: 1.2 + Math.random() * 1.6
        });
      }

      function resetGame() {
        obstacles = [];
        energy = [];
        score = 0;
        lastSpawn = 0;
        scoreAccumulator = 0;
        player.x = canvas.width / 2 - 16;
        player.vx = 0;
        status.textContent = 'Status: running · Score: 0';
      }

      function drawBackground() {
        ctx.fillStyle = '#05070d';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = 'rgba(124, 242, 156, 0.08)';
        ctx.beginPath();
        for (let x = 0; x <= canvas.width; x += 40) {
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
        }
        for (let y = 0; y <= canvas.height; y += 40) {
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();
      }

      function drawPlayer() {
        ctx.fillStyle = '#8ce0ff';
        ctx.fillRect(player.x, player.y, player.w, player.h);
        ctx.fillStyle = '#7cf29c';
        ctx.fillRect(player.x + 8, player.y - 6, player.w - 16, 6);
      }

      function drawObjects(list, color, glow) {
        ctx.fillStyle = color;
        list.forEach(obj => {
          ctx.beginPath();
          ctx.arc(obj.x + obj.size / 2, obj.y + obj.size / 2, obj.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = glow;
          ctx.stroke();
        });
      }

      const SCORE_INTERVAL_MS = 16; // target ~60fps cadence for incremental scoring
      function update(delta) {
        player.vx = 0;
        if (keys.has('left')) player.vx = -player.speed;
        if (keys.has('right')) player.vx = player.speed;
        player.x = Math.min(canvas.width - player.w, Math.max(0, player.x + player.vx));

        lastSpawn += delta;
        if (lastSpawn > SPAWN_INTERVAL_MS) {
          spawnObject(obstacles, 'rock');
          if (Math.random() > 0.5) spawnObject(energy, 'energy');
          lastSpawn = 0;
        }

        obstacles.forEach(o => o.y += o.speed * 3);
        energy.forEach(e => e.y += e.speed * 2.2);
        obstacles = obstacles.filter(o => o.y < canvas.height + o.size);
        energy = energy.filter(e => e.y < canvas.height + e.size);

        obstacles.forEach(o => {
          if (o.x < player.x + player.w &&
              o.x + o.size > player.x &&
              o.y < player.y + player.h &&
              o.y + o.size > player.y) {
            running = false;
            status.textContent = `Status: crashed · Final score: ${score}`;
          }
        });

        energy = energy.filter(e => {
          const hit = e.x < player.x + player.w &&
                      e.x + e.size > player.x &&
                      e.y < player.y + player.h &&
                      e.y + e.size > player.y;
          if (hit) score += 10;
          return !hit;
        });

        scoreAccumulator += delta;
        while (scoreAccumulator >= SCORE_INTERVAL_MS) {
          score += 1;
          scoreAccumulator -= SCORE_INTERVAL_MS;
        }
        status.textContent = running ? `Status: running · Score: ${score}` : status.textContent;
      }

      let last = performance.now();
      function loop(now) {
        if (!running) {
          cancelAnimationFrame(frameId);
          return;
        }
        const delta = now - last;
        last = now;

        drawBackground();
        update(delta);
        drawObjects(obstacles, '#ff9d76', 'rgba(255,157,118,0.4)');
        drawObjects(energy, '#7cf29c', 'rgba(124,242,156,0.35)');
        drawPlayer();
        frameId = requestAnimationFrame(loop);
      }

      function setRunning(next) {
        running = next;
        toggleBtn.textContent = running ? 'Pause' : 'Start';
        if (running) {
          last = performance.now();
          status.textContent = `Status: running · Score: ${score}`;
          frameId = requestAnimationFrame(loop);
        }
      }

      toggleBtn.addEventListener('click', () => setRunning(!running));
      resetBtn.addEventListener('click', () => {
        resetGame();
        setRunning(true);
      });

      resetGame();
    })();
  </script>
</body>
</html>
